# Ajouter du context

Parfois nos composants sont d√©pendant d'√©l√©ment externe, notamment le fait d'√™tre
√† l'int√©rieur d'un context. √áa arrive tr√®s souvent !

On pourrait simplement ajouter nos context autours de nos composants lors du render :

```tsx
render(
  <Context>
    <MyComponent />
  </Context>
);
```

Mais on se retrouverais √† devoir rappeler ce Context encore et encore dans chacun de nos
tests.

Pour r√©soudre ce probl√®me, `react-testing-library` nous offres de nombreuses solutions
plut√¥t original !

La fonction `render` prend en option un `wrapper` √©l√©ment qui va venir ajouter
du context √† notre composant.

```tsx
const Wrapper = (props: PropsWithChildren) => {
  return (
    <SomeWrapper>
      <AnotherWrapper>{props.children}</AnotherWrapper>
    </SomeWrapper>
  );
};

const customRender = (ui: ReactElement, options?: any /* √† toi de le mettre */) =>
  setup(ui, { wrapper: Wrapper, ...options });
```

Tu pourrais vouloir d√©placer cette fonction dans un fichier utilitaire nomm√© `renderApp`
afin de render notre application avec tous les providers.

```tsx
import { render } from '@testing-library/react';

const Wrapper = () => /*...*/

export const renderApp = (ui: ReactElement, options?: any /* √† toi de le mettre */) => {
  return setup(ui, { wrapper: Wrapper, ...options });
}
```

Tu vas pouvoir ensuite utiliser cette m√©thode partout ou tu as besoin de `render` ton
application avec les contexts.

Dans cette exercices on va test√© le composant `Dashboard`. Je m'excuse d'avance car ce
composant est pas tr√®s concret, au contraire, il est tr√®s abstrait car pas tr√®s utiles !

Mais tu retrouve le Login du d√©but, et surtout un th√®me Dark / Light.

On verras aussi dans cette exercises, commenter tester le context en lui m√™me.

## Part 1

Il va falloir que tu cr√©er une fonction `customRender` qui wrap notre composant avec le
`UserContextProvider` ainsi que le `ThemeContextProvider`.

Tu peux cr√©er le test suivant :

- V√©rifier que d√®s qu'on toggle le dark mode, le mode est correctement changer

## Part 2

Il est possible de "mock" nos providers, quand ceux-ci prennes des valeurs par d√©faut.

Dans un autre `describe`, on va tester un deuxi√®me component, dans le m√™me fichier : `DashboardHeader`. Il faut tester le cas ou il n'y a pas de user et le cas ou il y en as un.

Pour √ßa, tu peux suivre ce pattern :

```tsx
const Wrapper = ({ children, test }: PropsWithChildren<{ test?: string }>) => {
  return (
    <SomeWrapper test={test}>
      <AnotherWrapper>{props.children}</AnotherWrapper>
    </SomeWrapper>
  );
};

const customRender = (
  ui: ReactElement,
  options?: any /* il faut rajouter `test` dans les options */
) =>
  render(ui, {
    wrapper: ({ children }) => <Wrapper test={options.test}>{children}</Wrapper>,
    ...options,
  });
```

A toi de cr√©er les deux tests n√©cessaires pour notre `DashboardHeader`.

- üíå Notre wrapper peut √™tre utiliser pour tous les composants qui ont besoin de ce context

## Part 3

Comment on aurais pus tester un Provider ? Par exemple le ThemeProvider ?

Dans un autre `describe`, tout en bas de notre fichier, rajoute un test pour le theme provider !

Afin de tester ce provider, on va cr√©er un test composant qui va utiliser le ThemeProvider.

```tsx
const TestComponent = () => {
  const { theme, toggle } = useTheme();

  return (
    <div>{/* on va ici afficher le theme et le bouton pour toggle celui-ci */}</div>
  );
};

test('toggle theme will change the theme color', () => {
  // on va ici utiliser notre customRender pour tester le theme uniquement
});
```

Le but est de cr√©er un composant qui va nous permettre uniquement de v√©rifier que les donn√©es
change quand on appel la fonction Toggle par exemple.

Essaie de cr√©er un composants `TestComponent` tout simple, qui affiche juste le text `light` ou `dark` de theme et cr√©er le test qui permet de toggle.
