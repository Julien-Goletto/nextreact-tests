# Les tests sans React-testing-library

Pour bien comprendre les tests, je te propose de les d√©couvrir SANS utiliser
la librairie React-testing-library. C'est un peu plus compliqu√©, mais √ßa permet de
comprendre comment l'utilit√© de cette librairie.

Dans le premier exercice on va tester le composant `Counter` que tu peux retrouver dans
le dossier [src/components/counter/Counter.tsx](src/components/counter/Counter.tsx).

Tu peux tester ce composant avec l'URL http://localhost:5173/1-toggle !

La premi√®re √©tape c'est que tu d√©finisse dans ta t√™te : que faut-il tester ?

Quel feature de ce composant est important √† tester ?

Pose toi et r√©fl√©chie y. Tu peux aller voir le code pour encore plus facilement te
faire une id√©e.

## Partie 1

C'est partie pour √©crire les tests !

Dans le fichier [src/**tests**/exercices/1.test.tsx](src/__tests__/exercices/1.test.tsx)
tu peux voir que j'ai d√©j√† √©cris un bon nombre d'instruction.

Pour tester le composant `Counter`, il va falloir d√©j√† utiliser React pour ajouter
notre composant dans le DOM.

Ce que j'ai fais c'est que j'ai cr√©er une div que j'ai ajout√© dans le dom.

Puis j'utilise ReactDOM afin d'ajouter mon composant dans cette div.

```js
const div = document.createElement('div');
document.body.append(div);

const root = ReactDOM.createRoot(div);
root.render(<Counter />);
```

A ce stade tu peux tester ce qui se passe dans le dom avec :

```js
console.log(div.innerHTML);
```

Tu verras qu'il n'y a rien !

Car depuis la derni√®re mise √† jour, React est asyncrone et l'execution de notre code
**est plus rapide** que l'execution de React.

Pour r√©soudre ce probl√®me, on va utiliser la fonction `wait` que j'ai cr√©er dans le fichier [src/test/wait.ts](src/test/wait.ts).

```js
await wait();
```

Si tu ajoutes cette ligne avant le `console.log` tu verras que le dom est maintenant
rempli.

Ce que tu dois tester dans cette exercice :

- Quand on clique sur le bouton moins, le compteur diminue de 1

üíå Tu apprends √† tester sans aucune library.

## Partie 2

On va cr√©er un deuxi√®me test qui va cette fois tester ce qui se passe quand on clique
sur le bouton `+`.

C'est presque identifique √† notre premier test.

##¬†Partie 3

Ce code devient lourd non ? On va faire un petit refactor.

On va cr√©er une fonction `render` qui va nous permettre de cr√©er un composant dans le
dom.

```js
function render(Component: ReactNode) {
  // ...

  return div;
}
```

Ainsi qu'une fonction `click` pour simplif√© le code et √©viter de `wait(1)` partout !

```js
function click(element: HTMLElement) {
  // ...
}
```

Et on ne vas pas utiliser `element.click` pour faire notre action, on va plut√¥t
cr√©er un MouseEvent avec les bons param√®tres afin que notre click soit "comm" un vrai
click fait pas un utilisateur.

```js
function click(element: HTMLElement) {
  const event = new MouseEvent('click', {
    bubbles: true,
    cancelable: true,
    view: window,
  });

  element.dispatchEvent(event);
  // ...
}
```

##¬†Partie 4

Tu peux voir dans le composant qu'il est possible de passer une props `defaultValue` √† notre composant.

Il faut s'assurer que cette props est bien prise en compte lors du premier rendu du composant.

Pour √ßa tu peux cr√©er un test en ajoutant la props `defaultValue` √† notre composant.

```js
const div = render(<Counter defaultValue={1} />);
```

## Partie 5

Si tu regarde le composant Counter, tu verras qu'on passe une props `onChange` qui est
appel√© lorsque qu'on modifie la valeur du compteur.

On va donc cr√©er un test qui va v√©rifier que cette props est bien appel√© avec la bonne
valeurs.

Pour √ßa on va utilis√© un `mock` de vite : `vi.fn()`.

Ce hooks va enregistrer les arguments avec lequel il est appel√© ainsi que le nombre
de fois qu'il est appel√©.

Pour v√©rifier le nombre de fois tu peux faire :

```js
const mock = vi.fn();
expect(mock).toHaveBeenCalledTimes(1); // mock a √©t√© appel√© 1 fois
```

Pour v√©rifier qu'il a √©t√© appel√© avec les bon arguments :

```js
const mock = vi.fn();
expect(mock).toHaveBeenCalledWith(1); // mock a √©t√© appel√© avec l'argument 1
```

Mais `.toHaveBeenCalledWith` va juste v√©rifier que dans toutes les fois ou notre hooks
√† √©t√© appel√©, il a √©t√© appel√© en moins une fois avec l'argument `1`.

Tu peux aussi utiliser `.toHaveBeenNthCalledWith` pour v√©rifier que le hooks a √©t√©
appel√© avec l'argument `1` √† la deuxi√®me fois.

```js
const mock = vi.fn();
expect(mock).toHaveBeenNthCalledWith(2, 1); // mock a √©t√© appel√© avec l'argument 1 √† la deuxi√®me fois
```

Tu vas pouvoir cr√©er un test :

- Quand on clique sur le bouton moins, le compteur diminue de 1 et la props onChange est appel√© avec la bonne valeur (premi√®re fois)
- Quand on clique sur le bouton plus, le compteur augmente de 1 et la props onChange est appel√© avec la bonne valeur (deuxi√®me fois)
- Le nombre total de fois ou la props onChange est appel√© est de 2

Pour passer notre fonction onChange √† notre composant, on va utiliser la props `value` qui est un nombre.

```js
const div = render(<Counter onChange={onChange} />);
```

## FIN

Bravo ! Tu as termin√© tous les parties de l'exercices 1.

Fait une pose, va boire un caf√©, on se retrouve pour l'exercice 2.
