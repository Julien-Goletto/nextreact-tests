#¬†Les tests des hooks

Comment tester des hooks ?

C'est vraiment pas une chose facile, car les hooks sont directement li√©e aux composants,
mais ils n'ont pas d'interface graphique !

Le but des tests est de repr√©senter le plus fid√®lement possible l'utilisation de notre hook,
et les hooks sont toujours utiliser dans des composants. Il faudrait donc peut-√™tre rendre
nos hooks dans des composants ?

C'est ce qu'on va voir, car il y 4 moyens de tester nos hooks, et tu pourras choisir
le plus approprier dans tes use-case.

##¬†Part 1

Le hooks que l'on va tester c'est `useCounter` il retourne 5 √©l√©ments :

- `counter` qui repr√©sente le compteur
- `increment` qui va permettre de l'incr√©menter
- `decrement` qui va permettre de le d√©cr√©menter
- `setCounter` afin de d√©finir une valeur pr√©cise
- `reset` qui va red√©finir notre counter avec la initialValue

`initialValue` est le seul argument que prend notre hooks et il d√©finit sa valeur par d√©faut.

Pour r√©aliser ce premier test, tu vas cr√©er un composant `TestComponent` ou tu vas utiliser
le hooks et retourner des boutons pour int√©ragir avec le hooks, il faudra aussi afficher la
valeur du hooks.

##¬†Part 2

Au lieu d'utiliser un composant qui affiche des boutons etc... pour int√©ragir avec notre hooks,
on va d√©finir notre composant dans notre test et assign√© les valeurs de retours
√† une variable avec laquel on va pouvoir int√©ragir.

```ts
let counter: UseCounterOutput = null as unknown as UseCounterOutput;

const TestComponent = () => {
  counter = useCounter();

  return null;
};

render(<TestComponent />);
```

(ce code est ajouter directement dans le `test`)

En appelant `counter.setValue` ou `counter.count` tu vas pouvoir int√©ragir avec le hooks
directement dans tes tests.

Tu vas aussi pouvoir utiliser `act` pour simuler des int√©ractions avec le hooks.

```ts
act(() => {
  counter.setValue(10);
});
```

`act` est utils ici car on va update un state dans un test, `act` viens pr√©venir et attendre
que ce changement ce produise et ne cr√©er pas des bugs dans nos tests.

üìñ [Quand utiliser act](https://flyingsquirrel.medium.com/when-should-i-use-act-in-react-testing-library-d7dd22a3340e)
üìñ [Bien utiliser act](https://codilime.com/blog/why-should-you-be-grateful-for-act-warnings-in-react-tests/)
üìñ [act react docs](https://reactjs.org/docs/test-utils.html#act)

##¬†Part 3

On veut cr√©er un deuxi√®me test pour v√©rifier que la `initialValue` est bien d√©finit lors
du render de notre hooks.

Pour √ßa il faudrait refaire tout le setup qu'on √† fait juste avant. Pour √©viter de copier/coller
notre code on va cr√©er une fonction `setup` qui fait tout √ßa pour nous.

```ts
const setup = () => {
  // Oui, on ment √† TypeScript ici !
  const counter = {} as {
    current: UseCounterOutput;
  };

  const TestComponent = () => {
    counter.current = useCounter();

    return null;
  };

  render(<TestComponent />);

  return counter;
};
```

Une fois ceci fais tu vas pouvoir cr√©er un deuxi√®me test qui va utiliser cette fonction
pour faire le setup.

```ts
const counter = setup();
```

‚ö†Ô∏è Je te laisse customis√© ma fonction `setup` pour quel accept `initialValue` en argument !

##¬†Part 4

Bon je vais pas te mentir plus longtemps, il existe un fonction qui permet de faire tout √ßa
sans avoir besoin de cr√©er pleins de ligne de code etc...

```ts
import { renderHook } from '@testing-library/react';

const hook = renderHook(useCounter);
const counter = hook.result;

expect(counter.current.count).toBe(0);
```

Voil√† une fa√ßon simple de v√©rifier la valeur de notre hooks !

Tu peux supprimer ce qu'on √† fait et remplacer les deux tests avec `renderHook`.

Pour ajouter une valeur initial tu peux utiliser [initialProps](https://testing-library.com/docs/react-testing-library/api/#renderhook-options-initialprops).

```ts
const hook = renderHook(useCounter, { initialProps: 10 });
```

Ce qui va provoqu√© le rendu de notre hooks avec `10` comme valeur initial.

En appelant `hook.rerender` hook on va pouvoir modifier la valeur initial cette valeur
par d√©faut.
Dans le test tu peux v√©rifier que quand on modifie cette valeur avec `hook.rerender` rien n'est
chang√© √† nos tests.
